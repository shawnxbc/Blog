# Lambda Calculus

## 1. 引入

在计算机科学里，一个关乎本质的问题是计算的能力和局限是什么？为了回答这个问题，首先需要严格地定义什么是计算。图灵(Alan Mathison Turing)、丘奇(Alonzo Church)和哥德尔(Kurt Gödel)等人提出了不同的理论计算模型，包括图灵机、lambda演算以及一般递归函数等。已经严格证明，这些计算模型在能力上是等价的。由于这些模型的处理方式和叙述逻辑有所不同，人们对它们的应用场景形成了不同的偏好。通常来说，图灵机是最优雅简洁也是计算机科学里最常用的理论模型，数学家则倾向于使用递归函数，而lambda演算在最初问世的一段时间里，由于其本身难以理解，并没有多少人关注和发展这方面的工作。

事实上，丘奇提出lambda演算的时间，比图灵发表他那篇著名论文的时间还要早几个月。1936年，当时只有24岁的图灵，发表了一篇计算机科学的奠基性论文：《论可计算数及其在判定问题上的应用》(*On Computable Numbers, with an Application to the Entscheidungsproblem*)。但是当图灵仍在撰写论文的内容的时候，丘奇就已经完成了相关的工作并公开发表了。当时他们想要解决的目标是同一个问题，即希尔伯特(David Hilbert)提出的判定问题(就是图灵论文题目当中提到的Entscheidungsproblem，希尔伯特用的是德文，翻译成英文就是decision problem)。按照科学领域的一般传统，这基本意味着图灵的论文失去了弥足珍贵的开创性意义。所以，当图灵第一眼看到丘奇率先发表的成果时，他的内心无疑是极度沮丧的。然而后来，图灵发现他和丘奇解决问题的方式以及给出的证明思路完全不同，他的证明要明晰优雅地多。于是图灵在其论文的后面又添加了证明图灵机跟lambda演算在计算意义上的等价性证明。图灵机的概念要比lambda演算容易理解得多，甚至哥德尔都这样认为：他承认自己不能理解lambda演算，但却可以理解图灵机。因此，在后来较长的一段时间里，lambda演算都乏人问津。

随着计算机科学的发展，各式各样的编程语言相继出现，而lambda演算对这些编程语言的设计产生了巨大的影响。不知道读者是否看过《黑客与画家》，Paul Graham在这书里对Lisp语言表达出了近乎传教式的热爱，而Lisp就是基于lambda演算的直接实现。Lisp开创了编程语言领域许多重要且基础的概念，包括：自动内存管理、匿名函数、动态类型、条件分支、高阶函数和REPL等。以至于有人开玩笑说，任何新的编程语言都是在添加Lisp几十年前就已经拥有的特性罢了。鉴于之前我在网上找有关lambda演算的入门内容时基本没有发现符合要求的介绍性文章，所以我决定做一个这样的任务。主要的内容参考于亚利桑那州立大学的Adam Doupé博士，如果有兴趣你可以查看他在YouTube上关于这部分内容的讲座。

尽管电子计算机编程语言的出现晚于lambda演算，但从这些编程语言的角度来理解lambda演算是有益的。lambda演算实际是一种抽象程度很高的编程语言，跟我们熟悉的C或者Java类似，它有自己的语法和语义。lambda演算打交道的对象是函数，因此其核心的功能有两个：函数的定义和函数的应用。像上面提到的Lisp一样，现存的所有函数式语言，例如ML、Haskell、F#等，都起源于lambda演算。下面我们就开始正式介绍lambda演算的内容。

## 2. 语法

lambda演算中所有的字符串都是表达式或者λ项(expression or λ-calculus term)，我们从一个标识符(identifier)的可数无穷集合开始，例如 {a, b, c, ...}，定义以下几种情况：

- E → ID 。最简单的表达式就是一个变量或者标识符，例如a, b, c, ... 。
- E → λ ID . E 。第二种情况是函数抽象(functional abstraction)。
- E → E E 。 第三种情况是函数应用(functional application)。
- E → (E) 。最后一种情况是引入括号来组织表达式的结构。

上面就是lambda演算的语法，应该说比我们通常接触到的其他任何编程语言的语法都要简单，这就是高度抽象的好处。因为抽象意味着它剔除了实际工程中所需考虑的各种细节，而仅仅保留了最核心且必要的组件。上面的语法目前看起来可能比较难以理解，因为我们还没有介绍lambda演算的语义，到这我们只需要知道如何根据上面的规则来判断什么样的字符串是合法的lambda表达式。来看几个例子：

```
x								# 属于第一种情况，合法
λ x . x							# 属于第二种情况，合法
x y								# 属于第三种情况，合法
λ λ x . y						# λ后面必须跟一个ID，不合法
λ x . y z						# 合法，但这里如果仅依靠上面的规则，该表达式结构是模糊的
foo λ bar . (foo (bar baz))		# 合法，这是一个复合表达式，你可以递归地去分解它的结构
```

注意：在网上介绍lambda演算文章中，一般都不会引入空格，例如 `λ x . x` 会被写成 `λx.x` 。这种是为了书写上的简便，同时文章作者默认变量名为单个字符，也就不会出现像上面第六个表达式的情况。我们这篇文章中不会省略用于分隔的空格。

就上面给出的第五个表达式 `λ x . y z` 而言，如果你用上面定义lambda表达式的规则来套，既可以理解为 `λ x . (y z)` ，也可以理解为 `(λ x . y) z` ：

![image-20200524125958527](C:\Users\xiang\AppData\Roaming\Typora\typora-user-images\image-20200524125958527.png)

类似的，就表达式 `x y z` 而言，你既可以理解为 `(x y) z` ，也可以理解为 `x (y z)` ：

![image-20200524130208004](C:\Users\xiang\AppData\Roaming\Typora\typora-user-images\image-20200524130208004.png)

为了解决上面语法的歧义性，使得任何一种表达式都只有一种分解方式，我们引入两条新的规则：

- `E → E E` 函数的应用是左结合的，也就是说 `x y z` 等价于 `(x y) z` ，`w x y z` 等价于 `((w x) y) z` 。
- `λ ID . E`  函数的定义要从 `λ ID .` 开始尽可能地向右扩展，也就是说 `λ x . y z` 等价于 `λ x . (y z)` 。

## 3. 语义

当丘奇发展出lambda演算这套理论的时候，很多概念所使用的名称与现在不同。例如，在lambda演算中，函数的定义被称为函数抽象(functional abstraction)，函数的调用称为函数应用(functional application)。为了保持与原始术语一致的惯例，这篇文章也使用函数抽象和函数应用这两个名称。

如前所述，函数抽象的形式是 `λ ID . E` ，这定义了一个匿名函数：`ID` 代表这个函数的形式参数，`E` 是这个函数的函数体。函数应用的形式是 `E1 E2` ：左边的表达式 `E1` 是要调用的函数，右边的表达式 `E2` 是要传递给 `E1` 的参数。这里顺便提一句，丘奇选择 `λ` 这个符号也是相对偶然的结果。最开始，罗素和怀特海使用了 `X^` 来表示类抽象。然后，丘奇做了一点小的更改，使用 `^X` 来表示函数抽象。最后，为了方便打印，丘奇将 `^` 改成了 `λ` 。

我们来看一个例子。假设我们现在已经定义了接受两个参数的加法函数 `+` 和自然数 `1` 。(当然，到目前为止，我们还没有介绍在lambda演算里如何定义接受两个参数的函数以及自然数，但这里我们先把它们当作给定的元素。)

```
λ x . + x 1			# 这行是一个函数抽象，该函数接受一个参数x，然后把x加1。等价于 f(x) = x + 1
(λ x . + x 1) 2		# 这行是一个函数应用，将加1函数作用到参数2上，替换后就是 (+ 2 1) = 3
```

## 4. 柯里化(Currying)

在上面给出的函数抽象形式 `λ ID . E` 中，每个函数抽象只包含一个形式参数，那如何定义类似加法这种接受多个参数的函数呢？答案是柯里化。柯里化的想法很直接，就是通过返回函数抽象的方式将只接受一个参数的各个函数串连起来，实现接受多个参数的效果。来看一个例子：

```
λ x . λ y . ((+ x) y)			# 接受两个参数的函数抽象

(λ x . λ y . ((+ x) y)) 1		# 如果只提供一个参数，外层函数作用后返回内存的函数抽象
=> λ y . ((+ 1) y)

(λ x . λ y . ((+ x) y)) 10 20	# 如果提供两个参数，则发生链式作用，满足我们期待的效果
=> (λ y . ((+ 10) y)) 20
=> ((+ 10) 20) = 30
```

## 5. Free Variables vs. Bound Variables

我们称 `x` 是 `E` 中的自由变量，如果：

- `E = x`
- `E = λ y . E1` ，其中 `y != x` 并且 `x` 在 `E1` 中是自由的
- `E = E1 E2` ，其中 `x` 在 `E1` 中是自由的 或者 `x` 在 `E2` 中是自由的

我们称 `x` 是 `E` 中的绑定变量，如果：

- `E = λ y . E` ，其中 `y = x` 或者 `x` 在 `E` 中是绑定的
- `E = E1 E2` ，其中 `x` 在 `E1` 中是绑定的 或者 `x` 在 `E2` 中是绑定的

这里需要强调的一点是同一标识符在某个表达式中，既可能是自由的，也可能是绑定的。这种现象发生的原因在于标识符本身不具有特殊的含义，可以理解为占位符，而lambda演算跟其他编程语言一样变量有作用域的限制。因此，我们可以在不同的作用域下使用同一标识符。

```
x free in λ x . x y z?					# No
y free in λ x . x y z?					# Yes
x free in (λ x . (+ x 1)) x?			# 这里存在两个同名的x变量，左侧表达式中的x是绑定的，右侧表
										# 达式中的x是自由的。
z free in λ x . λ y . λ z . z y x?		# No
```

### 5.1 绑定变量的规则

在确定绑定变量究竟跟哪个函数抽象 `λ x` 所绑定时，由于变量名可能相同，有时候会让人感到困惑。 这里，我们显式地给出下列规则，来帮助确定绑定变量的绑定关系：

- 如果 `x` 在 `E` 中是自由的，那么在 `λ x . E` 中，这样的 `x` 会被 `λ x` 所绑定。
- 如果 `x` 在 `E` 中已经被某个特定的 `λ x` 绑定，那么在 `λ z . E` 中该 `x` 仍然被同样的 `λ x` 绑定，即便此时有 `z == x` 。例如，`λ x . λ x . x` 中左侧的 `x` 是跟左侧的 `λ x` 绑定的。
- 如果 `x` 在 `E1` 中已经被某个特定的 `λ x` 绑定，那么在 `E1 E2` 和 `E2 E1` 中仍然被同样的 `λ x` 绑定。

其实上面的这些规则，用更直觉的语言来描述就是在确定绑定变量的绑定情况时，查找顺序是由内到外由局部到全局。或者说当把函数抽象的函数体独立出来看时，只有函数体中的自由变量 `x` 会被元变量声明 `λ x` 绑定。下面是几个例子，被同一函数抽象 `λ x` 绑定的变量同时加粗：

- (λ **x** . **x** (λ *y* . **x** *y* z *y*) **x**) x y
- (λ **x** . λ *y* . **x** *y*) (λ z . x z)
- (λ **x** . **x** λ *x* . z *x*)

### 5.2 组合子(Combinators)

如果某个lambda表达式不含有任何自由变量，则称该表达式为组合子。事实上，自由变量可以理解为编程语言中的全局变量，它不受当前局部作用域的约束。而组合子由于没有使用全局变量，也就完全通过输入来确定输出。后面会看到，我们将使用组合子来定义加法、减法和自然数这样的概念。

```
λ x . λ y . x y x combinator?	# Yes
λ x . x combinator?				# Yes
λ z . λ x . x y z combinator?	# No
```

## 6. Evaluation Rules

### 6.1 Alpha Conversion

对于lambda演算中的函数抽象来说，我们选择标识符时其实具有随意性，很多时候即便字符形式上的函数抽象看起来不同，但本质上它们定义的都是同一个函数。比如， `λ x . x ` 跟 `λ y . y` 就是等价的函数抽象，它们均返回传递的参数本身(the identity function)。像这种两个函数只有绑定变量标识符选择上的差异的情况，我们将其描述为**alpha equivalence**。

当我们做后面马上介绍的beta规约时，变量标识符的冲突会带来严重的问题。比如，`(λ x . (λ y . x y)) y` 是个函数应用。当使用 `y` 去替换掉左侧函数绑定的 `x` 时，得到 `λ y . y y` ，这显然是错误的结果。错误的原因在于，替换 `x` 的 `y` 在最终结果中本来应该是自由变量，但由于局部重名被捕获成了绑定变量。解决的方法很简单，使用其他任何不会产生冲突的标识符**重命名**原来的绑定变量 `y` 即可，这种操作就称为**alpha conversion**。

这里我们给出重命名的操作指南，其中{y/x}表示使用y重命名x：

- x {y/x} = y
- z {y/x} = z, if x ≠ z
- (E~1~ E~2~) {y/x} = (E~1~ {y/x}) (E~2~ {y/x})
- (λ x . E) {y/x} = (λ y . E {y/x}) 
- (λ z . E) {y/x} = (λ z . E {y/x}), if x ≠ z

上述规则可能看起来比较抽象，但实际上你正常练习一下重命名的操作过后，不太复杂的重命名都可以一步到位。并且凭直觉就能完成相应的步骤，而不需要真正去记上面的这些规则。

下面是几个简单的重命名例子：

```
  (λ x . x) {foo/x}
- (λ foo . (x) {foo/x})
- (λ foo . (foo))

  ((λ x . x (λ y . x y z y) x) x y) {bar/x}
- (λ x . x (λ y . x y z y) x) {bar/x} (x) {bar/x} (y) {bar/x}
- (λ x . x (λ y . x y z y) x) {bar/x} (x) {bar/x} y
- (λ x . x (λ y . x y z y) x) {bar/x} bar y
- (λ bar . (x (λ y . x y z y) x) {bar/x}) bar y
- (λ bar . (bar (λ y . x y z y) {bar/x} bar)) bar y
- (λ bar . (bar (λ y . (x y z y) {bar/x} ) bar)) bar y
- (λ bar . (bar (λ y . (bar y z y)) bar)) bar y
```

### 6.2 Beta Reduction

在介绍beta reduction之前，首先需要介绍**替换**操作。替换操作是指用一个lambda表达式替换另一个lambda表达式的自由变量，形式上记作：`E[x→N]`，其中 `E` 和 `N` 均为lambda表达式，`x` 为变量。

像之前的重命名操作一样，我们给出替换的操作指南，其中[x→N]表示将自由变量x替换成表达式N：

- x [x→N] = N

- y [x→N] = y, if x ≠ y

- (E~1~ E~2~) [x→N] = (E~1~ [x→N]) (E~2~ [x→N])

- (λ x . E) [x→N] = (λ x . E) 

- (λ y . E) [x→N] = (λ y . E [x→N]) if x ≠ y and y is not a free variable in N

- (λ y . E) [x→N] = (λ y' . E {y'/y} [x→N]) if x ≠ y, y is a free variable in N, and y' is a fresh variable name

同样的，你在练习过一些替换操作后，就完全可以很容易写出结果，而不需要去记忆上面的规则。

下面是几个简单的替换例子：

```
(+ x 1) [x→2]
- (+ 2 1)						# x在左侧的表达式中为自由变量，故直接替换

(λ x . + x 1) [x→2]
- (λ x . + x 1)					# x在左侧的表达式中为绑定变量，故不做替换

(λ y . x y) [x→U V]				# 这里对应第五条规则
- λ y . u v y

(λ x . y x) [y→λ z . x z]		# 这里对应上述第六条规则
- (λ x . (λ z . x z) x)			# 由于要替换成的目标表达式中x为自由变量，而左侧表达式中x为绑定变量
- (λ w . (λ z . x z) w)			# 为了替换后自由变量被绑定，故先做重命名操作，再做替换。

(λ x . y x) [y→λ z . x z]
- (λ w . (y x){w/x} [y→λ z . x z])
- (λ w . (y w) [y→λ z . x z])
- (λ w . (y [y→λ z . x z] w [y→λ z . x z])
- (λ w . (λ z . x z) w)

(x (λ y . x y)) [x→y z]
- (x [x→y z] (λ y . x y) [x→y z])
- ((y z) (λ y . x y) [x→y z])
- (y z) (λ q . (x y){q/y}[x→y z])
- (y z) (λ q . (x q)[x→y z])
- (y z) (λ q . ((y z) q))
```

在lambda演算中，函数应用的执行结果是一个表达式序列，这个序列中的每一个步骤都称作**β-reduction**。β-reduction只能作用于**β-redux**，即函数应用形式((λ x . E) N)的表达式。**β-normal form**指的是不含有任何β-redux的表达式。**完全β-reduction**指的是将表达式中的所有β-redux都规约掉。

**β-reduction形式上的定义为：(λ x . E) N beta-reduces to E[x→N]**。也就是说，对应 `(λ x . E) N` 这样的函数应用，首先将左侧函数抽象的元变量声明拿掉，得到函数体 `E` 。由于拿掉了元变量声明，`E` 中原来被元变量绑定的 `x` 就变成了自由变量，然后再做替换 `E[x→N]` 。尽管这里的讨论看起来比较抽象，但实际**β-reduction** 就是lambda演算中函数调用的执行过程罢了。下面给出两个有关的定理：

- 如果表达式P有β-normal form，则其β-normal form在alpha equivalent的意义下唯一。
- **Church–Rosser Theorem**。如果表达式 $P$ 能beta规约到 $M$ 和 $N$ ，则必然存在一个λ项 $T$ ，使得 $M$ 能beta规约到 $T$ 且 $N$ 能beta规约到 $T$ 。

下面来看几个例子：

```
(λ x . x) y 
- x[x→y]
- y

(λ x . x (λ x . x)) (u r)
- (x (λ x . x))[x→(u r)]
- (u r) (λ x . x)

(λ x . y) ((λ z . z z) (λ w . w))	# 这里实际上有两种执行的顺序：一种是像这里所展示的那样，先求值后
- (λ x . y) (z z)[z→(λ w . w)]		# 面的参数；另一种是先不对后面的参数做处理，直接把它当成整体对
- (λ x . y) ((λ w . w) (λ w . w))	# (λ x . y)做β-reduction，一步就能得到最后的结果。这两种情况
- (λ x . y) (w)[w→(λ w . w)]		# 分别称为Eager Evaluation和Lazy Evaluation。根据上面给
- (λ x . y) (λ w . w)				# 出的定理，它们计算的结果最后是一致的。
- y[x→(λ w . w)]
- y

(λ x . x x) (λ x . x x)				# WoW~,这是一个循环！
(x x)[x→(λ x . x x)]
(λ x . x x) (λ x . x x)
(x x)[x→(λ x . x x)]
(λ x . x x) (λ x . x x)
…
```

---

介绍完lambda演算的基本内容后，从这里我们将开始一段令人惊艳的旅程。我们将会看到，如何将上面抽象的lambda演算表达式跟一些计算机科学领域里耳熟能详的名词联系起来。包括自然数、算术运算、条件判断和递归在内的各种概念都能用lambda演算刻画出来。

## 7. 算术系统

### 7.1 皮亚诺公理(Peano Axioms)

对于算术系统而言，自然数是基本的构成要素。19世纪时，意大利数学家皮亚诺给出了5条公理来定义自然数及自然数集合，称为皮亚诺系统。皮亚诺系统是满足以下公理的有序三元组$<M, F, e>$，其中 $M$ 为一个集合，$F$ 为 $M$ 到 $M$ 的函数，$e$为首元素，5条公理如下：

1. $e$ 属于集合 $M$ ；
2.  $M$ 在 $F$ 下封闭；
3. $e$ 不属于 $ranF$ ；
4.  $F$ 是单射的；
5. 如果 $M$ 的子集 $A$ 满足：① $e$ 属于 $A$ ；② $A$ 在 $F$ 下是封闭的，则 $A=M$ 。

在上面的描述中， $M$ 就是指代的自然数集合， $e$ 是自然数集合中开头的元素， $F$ 是从前一个自然数映射到后一个自然数的取后继操作。有时候，在讨论自然数的时候，0是不是最小的自然数会有争议。但就这里的皮亚诺系统而言，它只是在形式上要求自然数有一个首元素，而具体你把首元素理解为0还是1其实无关紧要。通过上述公理构建的自然数系统，尽管是抽象化的，但却抓住了我们日常对自然数的直觉体验：0后面是1，1后面是2，... 。

![image-20200526104116397](D:\NS\Home\lambda calculus\Lambda Calculus.assets\image-20200526104116397.png)

如果构建的系统不符合上述五条公理，则会出现各种奇奇怪怪的现象。举例来说，如果 $e$ 属于 $ranF$ ，那意味着某个自然数的后继是 $e$ ，可能就会出现两端都是无穷或者首尾相接产生循环的情况。如果 $F$ 不是函数，那自然数序列就会出现分叉；或者 $F$ 不是单射，那就会出现下图左侧的分支合并和循环。再谈谈第五条公理，这条公理被称为极小性公理，它实际的含义是说 $ M $ 只取满足其他公理要求的最小的集合，所以 $M$ 不会像下图底部那样包含两条平行的序列或者是其他形式的自然数的超集。第五条公理又称为数学归纳法原理，因为它本质就包含了数学归纳法的思想。当我们要证明某个命题对于自然数集 $M$ 都成立的时候，我们可以先定义 $M$ 中满足该命题的元素集合为 $A$ ，然后再证明做下面两个步骤：① 首元素 $e$ 属于 $A$ ；②  $A$ 对于取后继运算 $F$ 封闭。这样我们就证明了 $A=M$ ，也就证明了 $M$ 符合相应的命题。

![image-20200526104900388](D:\NS\Home\lambda calculus\Lambda Calculus.assets\image-20200526104900388.png)

### 7.2 Church's Numerals

在介绍完皮亚诺公理后，我们就可以了解lambda演算中构造自然数的方式了：**Church's Numerals**。

我们先直接给出Church's numerals的编码，然后再对其展开讨论：

```
0 = λ f . λ x . x
1 = λ f . λ x . f x
2 = λ f . λ x . f (f x)
3 = λ f . λ x . f (f (f x))
4 = λ f . λ x . f (f (f (f x)))
...
```

在lambda演算中，一切讨论都是基于函数的。所以我们可以看到，每个自然数都被编码成了二元函数。读者可能会感到疑惑，为什么我们可以直接使用类似 `f`或者 `x` 之类的符号，而不能直接使用像自然数 `0` 或者 `1` 这样的东西呢？之前我们说过，变量标识符的选择具有任意性，这些符号本身不带有任何意义，因此我们才能根据需要做重命名的操作。但像 `0` / `1` 这样的自然数不同，它们是携带有含义的，它们的含义就体现在自然数集的数学结构。对自然数进行编码，最核心的地方就是要刻画出自然数集的这种数学结构。仔细观察church's numerals的表达式可以发现，对应的自然数是几，函数体中的 `f` 就作用了多少次。

我们再给出church's numerals的**后继函数(successor function)**：

```
succ = λ n . λ f . λ x . f (n f x)
```

为什么后继函数是这样的形式呢？我们来看下这个后继函数的作用就知道了：

```
succ = λ n . λ f . λ x . f (n f x)
0 = λ f . λ x . x

succ 0
- (λ n . λ f . λ x . f (n f x)) 0
- λ f . λ x . f (0 f x)
- λ f . λ x . f ((λ f . λ x . x) f x)
- λ f . λ x . f x
- 1

succ 1
- (λ n . λ f . λ x . f (n f x)) 1
- λ f . λ x . f (1 f x)
- λ f . λ x . f ((λ f . λ x . f x) f x)
- λ f . λ x . f (f x)
- 2

...

n+1 = succ n
```

从上面的示例可以看出来，只要给出初始元素0和相应的后继函数，我们就能构造出整个自然数集。不难看出，这种构造的方式跟上面介绍的皮亚诺系统是一致的。同时0对应的lambda表达式的选择也很有意思，它跟后面我们将要介绍的布尔值False的表达式是相同的。

### 7.3 算术运算

#### 7.3.1 加法

像之前谈到的，lambda演算中一切结构的基础都是函数，与church's numerals对应的自然数加法 `add` 当然也是函数。自然数加法的模式是接受两个自然数作为输入，然后映射到另一个自然数输出，所以 `add` 首先要接受两个参数。又由于church's numerals中的自然数形式都是包含两个参数的函数，所以 `add` 应用于两个参数的输出结果仍然是一个接受两个参数的函数。这样加起来 `add` 就应该接受四个参数：

```
add = λ n . λ m . λ f . λ x . n f (m f x)
```

表面看来 `add` 的形式比较复杂，实际上原理很简单。church's numerals中自然数 $n$ 的表达式形式是规律性的：函数体中包含有 $n$ 个 `F` 作用于 `x` 。然后 `add m n` 的目的是要从输入 `m` 和 `n` 映射到 `m + n` ，而 `m + n` 就是函数体中包含 $m+n$ 个 `f` 作用于 `x` 的函数。`add` 函数体是 `n f (m f x)` ： `(m f x)` 就是先作用 $m$ 次 `F` ，`n f` 就是再作用 $n$ 次 `F` ，最后的结果就是 $m+n$ 次 `f` 。

先看第一步 `(m f x)` 的效果：

```
1 f x
- (λ f . λ x . f x) f x 
- f x							# 1 个 f

2 f x
- (λ f . λ x . f (f x)) f x
- f (f x)						# 2 个 f

3 f x
- (λ f . λ x . f (f (f x))) f x
- f (f (f x))					# 3 个 f
```

再看第二步 `n f E` 的效果，其中 `E` 表示 `(m f x)` 的求值结果：

```
# 假设m=2，n=1。那么上一步的求值结果E就是(f (f x))
1 f (f (f x))						# 这个式子相当于在(f (f x))上再作用1次f
- (λ f . λ x . f x) f (f (f x))		# 最后的结果就是3个f，就是3对应的lambda表达式的函数体
- f (f (f x))						

# 假设m=2，n=2。那么上一步的求值结果E就是(f (f x))
2 f (f (f x))						# 这个式子相当于在(f (f x))上再作用2次f
- (λ f . λ x . f (f x)) f (f (f x)) # 最后的结果就是4个f，就是4对应的lambda表达式的函数体
- f (f (f (f x))) 
```

到这里，读者应该能理解 `add` 的含义了吧。

#### 7.3.2 乘法

定义了加法 `add` 过后，我们可以通过 `add` 定义乘法 `mult` ：

```
mult = λ n . λ m . m (add n) 0
```

考虑到 $m * n$ 就等价于 $m$ 个 $n$ 相加，这样 `mult` 的理解也是很直接的。首先把 `(add n)` 视为整体当作 `addn` ，然后0代表初始和值，`m (add n) 0` 合起来就是把 `addn` 作用 $m$ 次到初始和值0上，也就是实现了乘法 。

下面是几个使用示例：

```
mult 0 1
- (λ n . λ m . m (add n) 0) 0 1
- (λ m . m (add 0) 0) 1
- 1 (add 0) 0
- add 0 0
- 0

mult 1 2
- (λ n . λ m . m (add n) 0) 1 2
- (λ m . m (add 1) 0) 2
- 2 (add 1) 0
- (add 1) ((add 1) 0)
- (add 1) (add 1 0)
- (add 1) (1)
- (add 1 1)
- 2
```

除了这里介绍的自然数、加法和乘法，你还可以通过lambda表达式定义整数、有理数、减法、除法等等的概念，有兴趣可以查找资料了解这方面的内容。

## 8. 条件判断

条件判断的依据是布尔值，所以首先我们介绍一种lambda演算中表示布尔值的方式：

```
T = (λ x . λ y . x)
F = (λ x . λ y . y)
```

在上面的代码中，True和False的表示方式都是接受两个参数的函数，其中True返回第一个参数，False返回第二个参数。仅仅看True和False的lambda项形式，我们很难理解这样做的道理。要理解布尔值的lambda定义，就要把它们跟其他的逻辑操作符和条件测试放在一起考虑。

注意，lambda演算中定义的函数都是匿名的。尽管我们已经介绍了用lambda项表示自然数、布尔值、算术运算操作符等等的内容，并且会用T或者F这样的名称，但实际上这些都只是简写或者标签。如果需要，我们可以随时可以把这些简写展开成具体的lambda函数抽象。

### 8.1 逻辑操作符

- `AND` 的定义如下：

  ```
  and = (λ a . λ b . a b F)
  ```

  我们试着做几个与运算：

  ```
  and T T
  - (λ a . λ b . a b (λ x . λ y . y))
  - (λ a . λ b . a b (λ x . λ y . y)) (λ x . λ y . x) (λ x . λ y . x)
  - (λ b . a b (λ x . λ y . y))[a →(λ x . λ y . x)] (λ x . λ y . x)
  - (λ b . (λ x . λ y . x) b (λ x . λ y . y)) (λ x . λ y . x)
  - ((λ x . λ y . x) b (λ x . λ y . y))[b→(λ x . λ y . x)]
  - (λ x . λ y . x) (λ x . λ y . x) (λ x . λ y . y)
  - (λ y . x)[x →(λ x . λ y . x)] (λ x . λ y . y)
  - (λ y . (λ x . λ y . x)) (λ x . λ y . y)
  - (λ x . λ y . x)[y→(λ x . λ y . y)]
  - (λ x . λ y . x)
  - T
  
  and T F
  - (λ a . λ b . a b F) T F
  - (λ b . a b F)[a→T] F
  - (λ b . T b F) F
  - (T b F)[b→F]
  - (T F F)
  - (λ x . λ y . x) F F
  - (λ y . x)[x→F] F
  - (λ y . F) F
  - F[y→F]
  - F
  
  and F T
  - (λ a . λ b . a b F) F T
  - F T F
  - F
  
  and F F
  - (λ a . λ b . a b F) F F
  - F F F
  - F
  ```

  我们可以看到当 `AND` 跟布尔值 `T` 和 `F` 结合起来的时候，形势就变得明朗了。对于不同的真值组合，`AND` 都给出了正确的答案。前面两个运算的过程写的比较繁琐，一步一步展开了再求值的。实际上，抓住 `T` 和 `F` 分别取输入的前一参数和后一参数这一特性后，整个过程完全可以像后面两个运算一样简单，并不需要对 `T` 或者 `F` 做展开。

- `OR` 的定义如下：

  ```
  or = (λ a . λ b . a T b)
  ```

  使用上述定义的 `OR` 做逻辑运算：

  ```
  or T T
  - (λ a . λ b . a T b) T T
  - T T T
  - T
  
  or T F
  - (λ a . λ b . a T b) T F
  - T T F
  - T
  
  or F T
  - (λ a . λ b . a T b) F T
  - F T T
  - T
  
  or F F
  - (λ a . λ b . a T b) F F
  - F T F
  - F
  ```

- `NOT` 的定义如下：

  ```
  not = (λ a . a F T)
  ```

  使用上述定义的 `NOT` 做逻辑运算：

  ```
  not T
  - (λ a . a F T) T
  - T F T
  - F
  
  not F
  - (λ a . a F T) F
  - F F T
  - T
  ```

### 8.2 逻辑测试

逻辑测试是要根据条件的真假，实现不同的路径选择：

```
if c then
	a
else
	b
```

对于我们要定义的 `IF` 操作符，要完成的功能就是：

```
if T a b = a
if F a b = b
```

下面给出 `IF` 的定义：

```
if = (λ a . a)
```

使用 `IF` 操作符进行求值：

```
if T a b			# 如果条件判断为真，则求值结果为a
- (λ a . a) T a b
- T a b
- a

if F a b
- (λ a . a) F a b	# 如果条件判断为假，则求值结果为b
- F a b
- b
```

## 9. Y组合子与递归

首先需要介绍一下**图灵完备**(turing complete)的概念。如果一个计算模型，能够用来模拟图灵机的运行，则称它是图灵完备的或者**computationally universal**。我们在上面已经介绍了通过lambda演算来实现布尔逻辑和算术系统，但对于一个图灵完备的计算模型来说，这些还不够，我们还需要有循环或者递归。但现在的麻烦在于lambda演算里的函数都是匿名的，像 `add` 、`mult` 这些都是我们自己给匿名函数贴的标签，我们可以在任何地方把 `add` 或者 `mult` 替换成相应的纯λ项。如此一来我们就不能做诸如在 `add ` 的内部使用 `add` 这类递归通常用的技术，因为这样会导致循环定义，你把这样定义里的 `add` 替换的时候，这样的替换过程会永远持续下去。

那么问题来了，匿名的函数没有办法实现循环或者递归吗？我们从阶乘这一递归的经典示例来展开讨论。

```
# n!的定义
n!
- fact(0) = 1
- fact(n) = n * 	fact(n-1)

# 在一般的编程语言中，实现n!是很容易的
int fact(int n)
{
  if (n == 0)
  {
    return 1;
  }
  return n * fact(n-1);
}

# 现在假设我们有检查参数是否为0的iszero函数和取前驱的predecessor函数
# 我们naively把上面的c语言代码翻译成lambda语言 :)
fact = (λ n . if (iszero n) (1) (mult n (fact (pred n)))

# oops！我们实际是没有办法写出上面的函数的，因为lambda演算中的函数都是匿名的 :(
# 所以下面介绍强大的Y组合子
```

### Y组合子

Y组合子的英文是Y Combinator，一般的读者可能看到这个名字首先想到的是那个Paul Graham创建的硅谷创业孵化器。当你读完下面的内容，理解了Y组合子的含义，你就知道为什么一个创业孵化器要取这个名字了。

Y组合子的定义如下：

```
Y = (λ x . λ y . y (x x y)) (λ x . λ y . y (x x y))
```

同样的，我们需要看看使用它的效果，才能感受到这个奇怪的东西的灵魂：

```
Y foo
- (λ x . λ y . y (x x y)) (λ x . λ y . y (x x y)) foo
- (λ y . y ((λ x . λ y . y (x x y)) (λ x . λ y . y (x x y)) y)) foo
- foo ((λ x . λ y . y (x x y)) (λ x . λ y . y (x x y)) foo)
- foo (Y foo)	# Y foo 的求值结果居然是 foo (Y foo)！Amazing!
- foo (foo (Y foo))
- foo (foo (foo (Y foo)))
…
```

借助Y组合子，我们更改原来naive的阶乘定义，给出下面的阶乘函数：

```
fact = (λ n . if (iszero n) (1) (mult n (fact (pred n))))		# naive的版本
fact = Y (λ f . λ n . if (iszero n) (1) (mult n (f (pred n))))  # refined后的版本
```

下面的截图是使用该阶乘函数的一个计算示例。（由于字符太多，直接把代码拷贝到这篇文章里看起来太乱，你可以在这里找到对应的源代码。）

![image-20200527141432816](D:\NS\Home\lambda calculus\Lambda Calculus.assets\image-20200527141432816.png)

这个过程虽然看起来比较复杂，但实际上宏观的直觉很清楚。由于我们把 `fact` 定义成了 `Y foo` 的形式，所以 `fact` 本身是能自我复制的。我们来看下求值过程的初始步骤：

```
fact 1
- Y foo 1
- foo (Y foo) 1
```

`fact` 的主逻辑在 `foo` 里。`foo` 接受两个参数：第一个是 `(Y foo)` ，也就是复制得到的 `fact` 函数；第二个是当前迭代到的数字。`foo` 里面是一个条件判断，如果当前的数字为0，则直接返回1；如果当前的数字不为0，则选择第二个分支。第二个分支是 `(mult n (f (pred n)))` ，其中的 `f` 就是传入的第一个参数 `(Y foo)` ，也就是 `fact` ，同时 `(pred n)` 就是 `n-1` 。所以第二个分支做的事情就是 `(mult n (fact n-1))`，这不就是我们想要的 `n * fact(n-1)` 吗？整个过程的逻辑就清楚了。: )

